#!/usr/bin/env bash
#------------------------------------------------------------------------------
#
# File:         centos_kernel_builder
#
# Description:  Build script for CentOS Stream kernel.
#
# The following two environment variables must be set:
# - KERNEL_SRC_DIR
# - KERNEL_BUILD_DIR
#
# Example:
# $ centos_kernel_builder -a aarch64 -s y10 -g -c -d -e chopin
#
# Works on Fedora 40 on x86_64 and aarch64 with gcc 14.2.1, but not Fedora 41.
#------------------------------------------------------------------------------

set -euo pipefail

BACKPORTING=false
BASE_CONFIG_FILE="none"
BRANCH_NAME="main"
BUILD_INITRAMFS=false
BUILD_RESULT=0
BUILD_RPM=false
CONFIGURE=false
CROSS_COMPILE_PREFIX=""
DEBUG_KERNEL=false
DEBUG_INITRAMFS=false
EXTRA_VERSION=""
FORK_NAME="redhat"
GIT_CLONE=false
HOST_TO_NOTIFY=""
INITRAMFS_FILES=()
KERNEL_CONFIG_FILE=""
KERNEL_DESCRIPTION=""
KERNEL_PREFIX=""
KERNEL_VERSION=""
MENUCONFIG=false
PATCHES_DIR=""
STREAM=""
TARGET_ARCH="x86_64"
UPSTREAM_REPO_NAME="stable"

BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
LIME_YELLOW=$(tput setaf 190)
BLUE=$(tput setaf 4)
BRIGHT_BLUE=$(tput setaf 12)
POWDER_BLUE=$(tput setaf 153)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)
BRIGHT=$(tput bold)
NORMAL=$(tput sgr0)
BOLD=$(tput bold)
BLINK=$(tput blink)
REVERSE=$(tput smso)
UNDERLINE=$(tput smul)

finish()
{
    local status="$1"   # 0 = success, non-zero = failure

    if [ -n "$HOST_TO_NOTIFY" ]; then
        local sound_file=$([[ "$status" -eq 0 ]] && \
            echo "/usr/share/sounds/freedesktop/stereo/complete.oga" || \
            echo "/usr/share/sounds/freedesktop/stereo/suspend-error.oga")
        
        ssh "$USER@$HOST_TO_NOTIFY" "paplay $sound_file" >/dev/null 2>&1
    fi

    exit "$status"
}

usage()
{
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  -a <x86_64|aarch64|riscv64>   Architecture"
    echo "  -b <branch-name>              CentOS Stream kernel fork branch"
    echo "  -B                            Prepare for backporting"
    echo "  -c                            Clean the build and configure kernel"
    echo "  -C <kernel-config-file>       Specify file with kernel configs"
    echo "  -d                            Build debug kernel"
    echo "  -D                            Build debug initramfs"
    echo "  -e                            Extra kernel version"
    echo "  -f <fork-name>                CentOS Stream kernel fork"
    echo "  -F <file-path>                initramfs files list"
    echo "  -g                            Git clone"
    echo "  -h                            Show help"
    echo "  -i                            Build an initramfs"
    echo "  -m                            Run menuconfig"
    echo "  -M <modules-list>             initramfs modules list"
    echo "  -p <patches-dir>              Patches directory"
    echo "  -r                            Build RPM packages"
    echo "  -s <y9|y10|z9|z10>            CentOS/RHEL kernel stream (Y-stream or Z-stream)"
    echo "  -t                            RT kernel"
    echo "  -u <next|stable>              Upstream kernel repository"
    echo ""

    finish 1
}

parse_args ()
{
    while getopts "a:b:BcC:dDe:f:F:ghimp:rs:tu:" opt
    do
        case $opt in
            a) TARGET_ARCH="$OPTARG" ;;
            b) BRANCH_NAME="${OPTARG%%:*}" ;;
            B) BACKPORTING=true ;;
            c) CONFIGURE=true ;;
            C) KERNEL_CONFIG_FILE="${OPTARG#*:}" ;;
            d) DEBUG_KERNEL=true ;;
            D) DEBUG_INITRAMFS=true ;;
            e) EXTRA_VERSION="${OPTARG#*:}" ;;
            f) FORK_NAME="${OPTARG%%:*}" ;;
            F) INITRAMFS_FILES+=( "$OPTARG" ) ;;
            g) GIT_CLONE=true ;;
            h) usage; exit ;;
            i) BUILD_INITRAMFS=true ;;
            m) MENUCONFIG=true ;;
            p) PATCHES_DIR="$OPTARG" ;;
            r) BUILD_RPM=true ;;
            s) STREAM="$OPTARG"
               case "${STREAM}" in
               y9)
                   KERNEL_GROUP="centos-stream"
                   REPO_NAME="centos-stream-9"
                   KERNEL_DESCRIPTION="CentOS Stream 9 (Y‑stream)"
                   KERNEL_PREFIX="cs9"
                   ;;
               y10)
                   KERNEL_GROUP="centos-stream"
                   REPO_NAME="centos-stream-10"
                   KERNEL_DESCRIPTION="CentOS Stream 10 (Y‑stream)"
                   KERNEL_PREFIX="cs10"
                   ;;
               z9)
                   KERNEL_GROUP="rhel"
                   REPO_NAME="rhel-9"
                   KERNEL_DESCRIPTION="RHEL 9 (Z‑stream)"
                   KERNEL_PREFIX="rhel9"
                   ;;
               z10)
                   KERNEL_GROUP="rhel"
                   REPO_NAME="rhel-10"
                   KERNEL_DESCRIPTION="RHEL 10 (Z‑stream)"
                   KERNEL_PREFIX="rhel10"
                   ;;
               *)
                   echo >&2 "${RED}${BOLD}Error: Invalid STREAM '${STREAM}'."
                   echo >&2 "       Must be one of: y9, y10, z9, z10."
                   echo "${NORMAL}"
                   exit 1
                   ;;
               esac
               ;;
            u) 
               if [[ "$OPTARG" == "stable" || "$OPTARG" == "next" ]]; then
                   UPSTREAM_REPO_NAME="$OPTARG"
               else
                   echo "${RED}${BOLD}Error: -b must be either 'stable' or 'next'"
                   echo "${NORMAL}"
                   usage
                   exit 1
               fi
               ;;
            \?) usage; exit 1 ;;
        esac
    done
}

check_args()
{
    if [[ -z "${TARGET_ARCH:-}" || -z "${STREAM:-}" ]]; then
        echo "${RED}${BOLD}Error: TARGET_ARCH and STREAM must both be set."
        echo "${NORMAL}"
        finish 1
    fi

    if [[ ${#INITRAMFS_FILES[@]} -gt 0 ]]; then
        for f in "${INITRAMFS_FILES[@]}"; do
            if [[ ! -f "$f" ]]; then
                echo "${RED}${BOLD}Error: initramfs file not found: ${CYAN}${f}"
                echo "${NORMAL}"
                finish 1
            fi
        done
    fi
}

create_log_file()
{
    local GCC_VERSION
    GCC_VERSION=$(gcc --version | head -n 1)

    local DATE_STR
    DATE_STR=$(date)

    local TIMESTAMP
    TIMESTAMP=$(date -d "today" +"%Y_%m_%d_%H%M")

    mkdir -p ~/logs
    LOG_FILE=~/logs/${KERNEL_PREFIX}_kernel_build_${TIMESTAMP}.log

    {
        echo "//---------------------------------------------------------------"
        echo "// ${KERNEL_DESCRIPTION} build log"
        echo "// ${DATE_STR}"
        echo "// KERNEL_SRC_DIR =   ${KERNEL_SRC_DIR}"
        echo "// KERNEL_BUILD_DIR = ${KERNEL_BUILD_DIR}"
        echo "// ${GCC_VERSION}"
        echo "//---------------------------------------------------------------"
        echo ""
    } > "${LOG_FILE}"

    echo "${WHITE}Log file: ${CYAN}${LOG_FILE}"
    echo "${NORMAL}"
}

apply_configs()
{
    if [[ ! -f "${KERNEL_CONFIG_FILE}" ]]; then
        echo "Error: config file not found: ${KERNEL_CONFIG_FILE}" >> "${LOG_FILE}"
        echo "${RED}${BOLD}Error: config file not found: ${CYAN}${KERNEL_CONFIG_FILE}"
        echo "${NORMAL}"
        finish 1
    fi

    echo "Applying kernel config from: ${KERNEL_CONFIG_FILE}" >> "${LOG_FILE}"
    echo "${WHITE}Applying kernel config from: ${CYAN}${KERNEL_CONFIG_FILE}"
    echo "${NORMAL}"

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "${line}" || "${line}" =~ ^[[:space:]]*# ]] && continue

        # Parse: <action> <symbol> [<value>]
        local action symbol value
        read -r action symbol value <<< "${line}"

        if [[ -z "${action}" || -z "${symbol}" ]]; then
            echo "Error: malformed line: ${line}" >> "${LOG_FILE}"
            echo "${RED}${BOLD}Error: malformed line: ${CYAN}${line}"
            echo "${NORMAL}"
            finish 1
        fi

        # For Kconfig symbol validation, search for lines like:
        #   config FOO
        #   menuconfig FOO
        local matches
        if ! matches=$(grep -Rwl --include='Kconfig*' \
                -e "^config[[:space:]]\+${symbol}$" \
                -e "^menuconfig[[:space:]]\+${symbol}$" \
                "${KERNEL_SRC_DIR}" 2>/dev/null); then
                matches=""
        fi

        if [[ -z "${matches}" ]]; then
            echo "Error: Unknown Kconfig symbol: ${symbol}" >> "${LOG_FILE}"
            echo "${RED}${BOLD}Error: Unknown Kconfig symbol: ${CYAN}${symbol}"
            echo "${NORMAL}"
            finish 1
        fi

        # Build scripts/config command
        local cmd=( "${KERNEL_SRC_DIR}/scripts/config"
                    --file "${KERNEL_BUILD_DIR}/.config"
                    "--${action}" "${symbol}" )

        [[ -n "${value}" ]] && cmd+=( "${value}" )

        # Apply config
        "${cmd[@]}" || {
            echo "Error: failed to apply: ${line}" >> "${LOG_FILE}"
            echo "${RED}${BOLD}Error: failed to apply: ${CYAN}${line}"
            echo "${NORMAL}"
            finish 1
        }
    done < "${KERNEL_CONFIG_FILE}"
}

generate_ctags()
{
    echo "${WHITE}"
    echo "Generating ctags..."
    echo "${NORMAL}"

    local TAGFILE="${KERNEL_BUILD_DIR}/tags"
    rm -f "${TAGFILE}"

    if ! command -v ctags >/dev/null 2>&1; then
        echo "${YELLOW}Skipping ctags: ctags not installed.${NORMAL}"
        return 0
    fi

    local CTAGS_BIN; CTAGS_BIN=$(command -v ctags)

    # Helper to detect whether an option exists
    ctags_supports() {
        "${CTAGS_BIN}" "$1" --help >/dev/null 2>&1
    }

    # Create ignore file in memory
    local IGNOREFILE
    IGNOREFILE=$(mktemp)
    cat > "${IGNOREFILE}" << 'EOF'
*.o
*.so
*.a
*.bin
*.ko
*.mod
*.cmd
*.d
*.symtypes
*.order
.git/*
tools/*
scripts/*
samples/*
Documentation/*
cscope.*
Module.symvers
vmlinux*
EOF

    # Build ctags argument list dynamically
    local CTAGS_ARGS=( -R --sort=no --tag-relative=yes -f "${TAGFILE}" )
    CTAGS_ARGS+=( --exclude=@${IGNOREFILE} )
    CTAGS_ARGS+=( --languages=C )

    if ctags_supports --workers; then
        CTAGS_ARGS+=( --workers="$(nproc)" )
    fi
    if ctags_supports --fields=+S; then
        CTAGS_ARGS+=( --fields=+S )
    fi
    if ctags_supports --extras=+F; then
        CTAGS_ARGS+=( --extras=+F )
    fi
    if ctags_supports --file-scope; then
        CTAGS_ARGS+=( --file-scope=yes )
    fi

    # Source directories
    local SOURCES=(
        "${KERNEL_SRC_DIR}/arch/arm64"
        "${KERNEL_SRC_DIR}/drivers"
        "${KERNEL_SRC_DIR}/fs"
        "${KERNEL_SRC_DIR}/kernel"
        "${KERNEL_SRC_DIR}/mm"
    )

    # Run ctags.
    "${CTAGS_BIN}" "${CTAGS_ARGS[@]}" "${SOURCES[@]}" \
        2> >(grep -v 'file-scope' >&2)

    local status=$?
    rm -f "${IGNOREFILE}"

    if [[ ${status} -ne 0 ]]; then
        echo "${RED}${BOLD}Error:${NORMAL} Failed to generate tags"
        finish 1
    fi
}

check_commands()
{
    local required_cmds=(
        "git" "make" "gcc" "ld" "ctags" "cpupower" "bc"
        "perl" "python3" "flex" "bison" "patch" "dtc"
        "xz" "unzip" "rsync"
    )

    for cmd in "${required_cmds[@]}"; do
        if ! command -v "${cmd}" > /dev/null 2>&1; then
            echo "${RED}${BOLD}Error: ${cmd} is required but not installed. Exiting."
            echo "${NORMAL}"
            finish 1
        fi
    done
}

check_dts_sanity()
{
    local DTS_DIR="$1"
    local MAKEFILE="${DTS_DIR}/Makefile"
    local MISSING=false

    echo "${WHITE}Checking DTS sanity:"
    echo "${WHITE}DTS dir: ${CYAN}${DTS_DIR}${NORMAL}"

    # Ensure DTC exists.
    if ! command -v dtc >/dev/null 2>&1; then
        echo "${RED}${BOLD}Error: device tree compiler (dtc) not found.${NORMAL}"
        echo "Install it with: sudo dnf install dtc"
        finish 1
    fi

    # Ensure Makefile exists.
    if [[ ! -f "${MAKEFILE}" ]]; then
        echo "${RED}${BOLD}Error: Makefile not found in ${DTS_DIR}${NORMAL}"
        finish 1
    fi

    # Verify all DTB entries have a matching .dts file.
    while read -r dtb; do
        [[ -z "${dtb}" ]] && continue
        local dts_file="${dtb%.dtb}.dts"
        if [[ ! -f "${DTS_DIR}/${dts_file}" ]]; then
            echo "${RED}${BOLD}Missing DTS source for: ${dtb}${NORMAL}"
            MISSING=true
        fi
    done < <(
        grep -oE '([[:space:]=]|^)[a-zA-Z0-9._+-]+\.dtb' "${MAKEFILE}" \
            | sed 's/^[[:space:]=]*//' \
            | grep -v '\.dtbo$' \
            | sort -u
    )

    if [[ "${MISSING}" == "true" ]]; then
        echo "${RED}${BOLD}DTS sanity check failed for ${DTS_DIR}.${NORMAL}"
        echo "Some DTB entries are missing corresponding .dts files."
        finish 1
    fi

    echo ""
}

apply_kernel_patches()
{
    # Enable nullglob to avoid errors if no patch files are found
    shopt -s nullglob

    echo ""
    echo "${WHITE}Applying patches from ${BRIGHT_BLUE}${BOLD}${PATCHES_DIR}..."
    echo "${NORMAL}"

    local PATCHES_FOUND=false

    for PATCH_FILE in "${PATCHES_DIR}"/*.patch; do
        if [[ -f "${PATCH_FILE}" ]]; then
            PATCHES_FOUND=true
            echo "${CYAN}${PATCH_FILE}${NORMAL}"
            git am "${PATCH_FILE}" || {
                echo "${RED}${BOLD}"
                echo "Error: Failed to apply patch ${BRIGHT_BLUE}${BOLD}${PATCH_FILE}"
                echo "${NORMAL}"
                git am --abort
                finish 1
            }
        fi
    done

    if [[ "${PATCHES_FOUND}" != "true" ]]; then
        echo "${RED}${BOLD}Error: No patches found in ${BRIGHT_BLUE}${BOLD}${PATCHES_DIR}"
        echo "${NORMAL}"
        finish 1
    fi
}

set_target_architecture()
{
    case "${TARGET_ARCH}" in
        aarch64)
            MAKE_ARCH="arm64"
            if [[ "$(uname -m)" != "aarch64" ]]; then
                CROSS_COMPILE_PREFIX="aarch64-linux-gnu-"
            else
                CROSS_COMPILE_PREFIX=""
            fi
            ;;  
        riscv64)
            MAKE_ARCH="riscv"
            if [[ "$(uname -m)" != "riscv64" ]]; then
                CROSS_COMPILE_PREFIX="riscv64-linux-gnu-"
            else
                CROSS_COMPILE_PREFIX=""
            fi
            ;;  
        x86_64) 
            if [[ "$(uname -m)" != "x86_64" ]]; then
                echo "${RED}${BOLD}Error: attempting to build for x86_64 on a non-x86_64 system."
                echo "${NORMAL}"
                finish 1
            fi
            MAKE_ARCH="x86_64"
            CROSS_COMPILE_PREFIX=""
            ;;
        *) 
            echo "${RED}${BOLD}Invalid architecture specified: $TARGET_ARCH. Supported: aarch64, riscv64, x86_64."
            echo "${NORMAL}"
            finish 1
            ;;
    esac
}

prepare_for_backporting()
{
    echo "${WHITE}Preparing for backporting..."
    echo "${NORMAL}"

    # Change into the kernel source directory
    if [[ -d "${KERNEL_SRC_DIR}" ]]; then
        cd "${KERNEL_SRC_DIR}" || {
            echo "${RED}${BOLD}Error: Failed to cd into ${KERNEL_SRC_DIR}${NORMAL}"
            finish 1
        }
    else
        echo "${RED}${BOLD}Error: Kernel source directory ${KERNEL_SRC_DIR} does not exist.${NORMAL}"
        finish 1
    fi

    # Add CentOS/RHEL Y-stream or Z-stream kernel source repo as a remote.
    case "${STREAM}" in
        y9)
            git remote add cs9 "https://gitlab.com/redhat/centos-stream/src/kernel/centos-stream-9.git"
            git fetch cs9
            ;; 
        y10)
            git remote add cs10 "https://gitlab.com/redhat/centos-stream/src/kernel/centos-stream-10.git"
            git fetch cs10
            ;;
        z9)
            git remote add rhel9 "https://gitlab.com/redhat/rhel/src/kernel/rhel-9.git"
            git fetch rhel9
            ;;
        z10)
            git remote add rhel10 "https://gitlab.com/redhat/rhel/src/kernel/rhel-10.git"
            git fetch rhel10
            ;;
        *)
            echo "${RED}${BOLD}Error: invalid kernel source repo (must be Y-stream or Z-stream)${NORMAL}"
            finish 1
            ;;
    esac

    # Add upstream kernel source repo as a remote.
    if [[ "${UPSTREAM_REPO_NAME}" == "stable" ]]; then
        git remote add linux-stable "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git"
        git fetch -q linux-stable
    elif [[ "${UPSTREAM_REPO_NAME}" == "next" ]]; then
        git remote add linux-next "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git"
        git fetch linux-next "+refs/heads/*:refs/remotes/linux-next/*" "+refs/tags/*:refs/tags/*"
    fi

    echo ""
}

clone_kernel_repos()
{
    # Remove the current kernel source dir if it exists.
    if [[ -d "${KERNEL_SRC_DIR}" ]]; then
        echo "${YELLOW}${BOLD}"
        echo "WARNING: The kernel source directory exists."
        read -p "Are you sure you want to remove the existing workspace? Type 'yes' to confirm: ${NORMAL}" CONFIRMATION
        CONFIRMATION=${CONFIRMATION:-no} # Default to 'no'
        echo "${NORMAL}"
        if [[ "$CONFIRMATION" == "yes" ]]; then
            echo "${WHITE}Removing ${BRIGHT_BLUE}${BOLD}$KERNEL_SRC_DIR...${NORMAL}"
            echo "${WHITE}Removing ${BRIGHT_BLUE}${BOLD}$KERNEL_BUILD_DIR..."
            echo "${NORMAL}"
            rm -rf "${KERNEL_SRC_DIR}"
            rm -rf "${KERNEL_BUILD_DIR}"
        else
            echo "${WHITE}Workspace was not removed. Please reconsider your life choices."
            echo "${NORMAL}"
            finish 1
        fi
    fi

    if [[ "${FORK_NAME}" == "redhat" ]]; then
        RHEL_KERNEL_URL="https://gitlab.com/${FORK_NAME}/${KERNEL_GROUP}/src/kernel/${REPO_NAME}.git"
    else
        RHEL_KERNEL_URL="https://gitlab.com/${FORK_NAME}/${REPO_NAME}.git"
    fi

    echo "${WHITE}Cloning ${KERNEL_DESCRIPTION} kernel source tree...${NORMAL}"
    echo ""

    git clone "${RHEL_KERNEL_URL}" "${KERNEL_SRC_DIR}" || {
        echo >&2 "${RED}${BOLD}Error: cloning '${REPO_NAME}' failed. Check RHEL kernel URL or permissions."
        echo "${NORMAL}"
        finish 1
    }

    cd "${KERNEL_SRC_DIR}"

    echo "${WHITE}"
    echo "Checking out branch: ${CYAN}${BRANCH_NAME}${NORMAL}"
    echo "${NORMAL}"

    git fetch origin "${BRANCH_NAME}" >/dev/null 2>&1 || {
        echo >&2 "${RED}${BOLD}Error: remote branch '${BRANCH_NAME}' does not exist."
        echo "${NORMAL}"
        finish 1
    }

    git switch -C "${BRANCH_NAME}" "origin/${BRANCH_NAME}" || {
        echo >&2 "${RED}${BOLD}Error: failed to switch to branch '${BRANCH_NAME}'."
        echo "${NORMAL}"
        finish 1
    }

    echo "${NORMAL}"
}

select_base_config()
{
    local stream="$1"   # y9, y10, z9, z10
    local arch="$2"     # aarch64, x86_64, riscv64

    local pattern=""

    # Select configuration family based on stream
    case "$stream" in
        y9|z9)
            # kernel-5.x.x-<arch>.config
            if [[ "$DEBUG_KERNEL" == true ]]; then
                pattern="kernel-5.*-${arch}-debug.config"
            else
                pattern="kernel-5.*-${arch}.config"
            fi
            ;;
        y10|z10)
            # kernel-6.x.x-<arch>.config
            if [[ "$DEBUG_KERNEL" == true ]]; then
                pattern="kernel-6.*-${arch}-debug.config"
            else
                pattern="kernel-6.*-${arch}.config"
            fi
            ;;
        *)
            echo "Error: invalid stream '$stream' (expected y9,y10,z9,z10)" >> "${LOG_FILE}"
            echo "${RED}${BOLD}Error: invalid stream ${CYAN}'$stream' (expected y9,y10,z9,z10)"
            echo "${NORMAL}"
            finish 1
            ;;
    esac

    # Find matching config file
    BASE_CONFIG_FILE=$(ls redhat/configs/${pattern} 2>/dev/null | head -n1)

    if [[ -z "$BASE_CONFIG_FILE" ]]; then
        echo "Error: No base config found matching pattern:" >> "${LOG_FILE}"
        echo "${RED}${BOLD}Error: No base config found matching pattern:"
        echo "  redhat/configs/${CYAN}${pattern}"
        echo "${NORMAL}"
        finish 1
    fi
}

generate_config()
{
    echo "${WHITE}Generating kernel config...${NORMAL}"
    echo "Generating kernel config..." >> "${LOG_FILE}"
    echo "" >> "${LOG_FILE}"

    local distcfg_log="${KERNEL_BUILD_DIR}/dist-configs.log"

    if ! make "-j$(nproc)" dist-configs >> "${LOG_FILE}" 2>&1; then
        echo "" >> "${LOG_FILE}"
        echo "Error: make dist-configs failed" >> "${LOG_FILE}"
        echo "${RED}${BOLD}Error: make dist-configs failed"
        echo "${NORMAL}"
        finish 1
    fi

    select_base_config "${STREAM}" "${TARGET_ARCH}"
    echo "${WHITE}Base kernel config file: ${CYAN}${BASE_CONFIG_FILE}${NORMAL}"
    echo "" >> "${LOG_FILE}"
    echo "Base kernel config file: ${BASE_CONFIG_FILE}" >> "${LOG_FILE}"
    echo "" >> "${LOG_FILE}"

    # Copy base config file to the build directory.
    cp "${BASE_CONFIG_FILE}" "${KERNEL_BUILD_DIR}/"
    cp "${BASE_CONFIG_FILE}" "${KERNEL_BUILD_DIR}/.config"
}

clean_and_configure()
{
    echo "${WHITE}Cleaning kernel build..."
    echo "${NORMAL}"
    echo "Cleaning kernel build..." >> "${LOG_FILE}"
    echo "" >> "${LOG_FILE}"
    rm -rf ~/rpmbuild
    rm -rf "${KERNEL_BUILD_DIR}"; sync
    mkdir -p "${KERNEL_BUILD_DIR}"

    # Generate a config to use as a starting point.
    generate_config

    # Apply configs from input file if provided.
    if [[ -n "${KERNEL_CONFIG_FILE:-}" ]]; then
        apply_configs
    fi

    # Clean the kernel source tree.
    echo "" >> "${LOG_FILE}"
    echo "Cleaning the source tree..." >> "${LOG_FILE}"
    echo "${WHITE}Cleaning the source tree..."
    echo "${NORMAL}"
    make ARCH="${MAKE_ARCH}" mrproper

    # Prevent mismatched kernel version strings.
    scripts/config --file $KERNEL_BUILD_DIR/.config \
    --set-str LOCALVERSION "" \
    --disable LOCALVERSION_AUTO

    # olddefconfig updates the config by resolving unset options and
    # reconciling configs according to the kernel’s current Kconfig
    # dependencies and defaults, effectively enforcing consistency and
    # applying necessary corrections.
    echo ""
    echo "" >> "${LOG_FILE}"
    echo "Running olddefconfig..." >> "${LOG_FILE}"
    echo "${WHITE}Running olddefconfig..."
    echo "${NORMAL}"
    if ! KCONFIG_NONINTERACTIVE=1 make \
            O="${KERNEL_BUILD_DIR}" \
            ARCH="${MAKE_ARCH}" \
            olddefconfig; then

        echo "Error: olddefconfig failed. Aborting." >> "${LOG_FILE}"
        echo "${RED}${BOLD}Error: olddefconfig failed. Aborting."
        echo "${NORMAL}"
        finish 1
    fi

    # Run menuconfig if requested.
    if "${MENUCONFIG}"; then
        if [[ -n "${KERNEL_BUILD_DIR}" ]]; then
            if [[ -n "${CROSS_COMPILE_PREFIX}" ]]; then
                make ARCH="${MAKE_ARCH}" \
                     CROSS_COMPILE="${CROSS_COMPILE_PREFIX}" \
                     O="${KERNEL_BUILD_DIR}" menuconfig
            else
                make ARCH="${MAKE_ARCH}" \
                     O="${KERNEL_BUILD_DIR}" menuconfig
            fi
        fi
    fi
}

build_kernel()
{
    echo "" >> "${LOG_FILE}"

    case "${STREAM}" in
        y9)
            echo "${WHITE}Building CentOS Stream 9 kernel...${NORMAL}"
            echo "Building CentOS Stream 9 kernel..." >> "${LOG_FILE}"
            ;;
        y10)
            echo "${WHITE}Building CentOS Stream 10 kernel...${NORMAL}"
            echo "Building CentOS Stream 10 kernel..." >> "${LOG_FILE}"
            ;;
        z9)
            echo "${WHITE}Building RHEL 9 kernel...${NORMAL}"
            echo "Building RHEL 9 kernel..." >> "${LOG_FILE}"
            ;;
        z10)
            echo "${WHITE}Building RHEL 10 kernel...${NORMAL}"
            echo "Building RHEL 10 kernel..." >> "${LOG_FILE}"
            ;;
        *)
            echo "${RED}${BOLD}Error: Invalid STREAM '{CYAN}${STREAM}'."
            echo "${NORMAL}"
            finish 1
            ;;
    esac

    # Set identifier for the custom kernel build.
    if [ -n "${EXTRA_VERSION}" ]; then
        sed -i "s/^EXTRAVERSION.*/EXTRAVERSION = -${EXTRA_VERSION}/" "${KERNEL_SRC_DIR}/Makefile"
    fi

    # Build command setup
    if [[ -n "${CROSS_COMPILE_PREFIX}" ]]; then
        MAKE_CMD=(
            make -j"$(nproc)"
            O="${KERNEL_BUILD_DIR}"
            ENABLE_WERROR=
            CROSS_COMPILE="${CROSS_COMPILE_PREFIX}"
            ARCH="${MAKE_ARCH}"
        )
    else
        MAKE_CMD=(
            make -j"$(nproc)"
            O="${KERNEL_BUILD_DIR}"
            ENABLE_WERROR=
            ARCH="${MAKE_ARCH}"
        )
    fi

    echo "" >> "${LOG_FILE}"
    echo "Build command: KCONFIG_NONINTERACTIVE=1 ${MAKE_CMD[*]}" >> "${LOG_FILE}"
    echo "" >> "${LOG_FILE}"

    # Execute the build command
    KCONFIG_NONINTERACTIVE=1 "${MAKE_CMD[@]}" >> "${LOG_FILE}" 2>&1
    BUILD_EXIT_STATUS=$?
    echo "" >> "${LOG_FILE}"

    # Build RPM packages if requested
    if [[ "${BUILD_RPM}" == "true" ]]; then
        echo "Running: make -j$(nproc) binrpm-pkg O=${KERNEL_BUILD_DIR}" >> "${LOG_FILE}"
        (
            cd "${KERNEL_SRC_DIR}" &&
            make -j"$(nproc)" O="${KERNEL_BUILD_DIR}" binrpm-pkg >> "${LOG_FILE}" 2>&1
            cp "$HOME/rpmbuild/RPMS/${TARGET_ARCH}"/*.rpm "${KERNEL_BUILD_DIR}" 2>/dev/null || true
        )
        BUILD_EXIT_STATUS=$?
    fi

    END_TIME=$(date +%s)
    BUILD_DURATION=$((END_TIME - START_TIME))
    BUILD_MINUTES=$((BUILD_DURATION / 60))
    BUILD_SECONDS=$((BUILD_DURATION % 60))

    BUILD_RESULT=1
    case "${TARGET_ARCH}" in
        aarch64)
            IMAGE_FILE="${KERNEL_BUILD_DIR}/arch/arm64/boot/Image"
            if [[ ${BUILD_EXIT_STATUS} -eq 0 && -f "${IMAGE_FILE}" ]]; then
                BUILD_RESULT=0
            fi
            ;;
        riscv64)
            IMAGE_FILE="${KERNEL_BUILD_DIR}/arch/riscv/boot/Image"
            if [[ ${BUILD_EXIT_STATUS} -eq 0 && -f "${IMAGE_FILE}" ]]; then
                BUILD_RESULT=0
            fi
            ;;
        x86_64)
            VMLINUX_FILE="${KERNEL_BUILD_DIR}/vmlinux"
            if [[ ${BUILD_EXIT_STATUS} -eq 0 && ( -f "${VMLINUX_FILE}" || -f "${KERNEL_SRC_DIR}/vmlinux" ) ]]; then
                BUILD_RESULT=0
            fi
            ;;
        *)
            echo "${RED}${BOLD}Unknown TARGET_ARCH: ${TARGET_ARCH}${NORMAL}"
            ;;
    esac

    return ${BUILD_RESULT}
}

build_initramfs()
{
    echo ""
    echo "" >> "${LOG_FILE}"
    echo "${WHITE}Building initramfs (inside CentOS Stream 10 container)...${NORMAL}"
    echo "Building initramfs (inside CentOS Stream 10 container)..." >> "${LOG_FILE}"
    echo "" >> "${LOG_FILE}"

    if ! command -v podman >/dev/null 2>&1; then
        echo "${RED}${BOLD}Error:${NORMAL} podman not found"
        finish 1
    fi

    # Check that kernel modules are staged.
    : "${KERNEL_MODROOT:=${KERNEL_BUILD_DIR}/modules_staging}"

    if [[ ! -d "${KERNEL_MODROOT}/lib/modules" ]]; then
        echo "${RED}${BOLD}Error:${NORMAL} kernel modules not staged (${KERNEL_MODROOT})"
        finish 1
    fi

    module_dirs=("${KERNEL_MODROOT}/lib/modules"/*)
    if [[ ${#module_dirs[@]} -ne 1 ]]; then
        echo "${RED}${BOLD}Error:${NORMAL} expected exactly 1 modules dir, found ${#module_dirs[@]}"
        finish 1
    fi

    KERNEL_VERSION=$(basename "${module_dirs[0]}")
    INITRAMFS_PATH="${KERNEL_BUILD_DIR}/initramfs-${KERNEL_PREFIX}-${KERNEL_VERSION}.img"

    BASE_ARGS=(
        --no-hostonly

        --add base
        --add kernel-modules
        --add udev-rules

        --add systemd
        --add systemd-initrd
        --add dracut-systemd

        --add fs-lib
        --add rootfs-block
    )

    # Optional debugging modules
    DEBUG_ARGS=()
    if [[ "${DEBUG_INITRAMFS}" == true ]]; then
        echo "Enabling debug initramfs options..." >> "${LOG_FILE}"
        echo "${WHITE}Enabling debug initramfs options...${NORMAL}"

        DEBUG_ARGS+=(
            --add debug
            --kernel-cmdline "console=ttyS2,1500000 rd.debug rd.shell"
        )
    fi

    ALL_ARGS=( "${BASE_ARGS[@]}" "${DEBUG_ARGS[@]}" )
    ALL_ARGS_STRING=$(printf " %q" "${ALL_ARGS[@]}")

    # Include the specified files in the initramfs.
    if [[ ${#INITRAMFS_FILES[@]} -gt 0 ]]; then
        echo "Adding custom files to initramfs staging..." >> "${LOG_FILE}"
        for src in "${INITRAMFS_FILES[@]}"; do
            if [[ ! -f "$src" ]]; then
                echo "Error: initramfs file not found: $src" >> "${LOG_FILE}"
                echo "${RED}${BOLD}Error: initramfs file not found: ${CYAN}$src${NORMAL}"
                finish 1
            fi
    
            # Put them under /usr/bin inside the initramfs
            install_path="${KERNEL_BUILD_DIR}/initramfs_extra/usr/bin"
            mkdir -p "${install_path}"
    
            cp "$src" "${install_path}/" || {
                echo "Error copying $src" >> "${LOG_FILE}"
                finish 1
            }
        done
    fi

    # Run dracut inside a container.
    echo "${WHITE}Running dracut...${NORMAL}"
    echo "Running dracut with: ${ALL_ARGS_STRING}" >> "${LOG_FILE}"
    if ! podman run --rm \
        --privileged \
        -v "${KERNEL_BUILD_DIR}:/workspace/build" \
        -v "${KERNEL_MODROOT}/lib/modules/${KERNEL_VERSION}:/lib/modules/${KERNEL_VERSION}:ro" \
        -w /workspace/build \
        quay.io/centos/centos:stream10 \
        bash -c "
            set -euo pipefail
            exec > >(tee /workspace/build/podman_dracut_full.log) 2>&1
    
            dnf -y install dracut dracut-network systemd kmod kernel-core
    
            if [[ ! -d /usr/lib/dracut/modules.d ]]; then
                echo 'Error: dracut modules directory missing in container.'
                exit 1
            fi
    
            dracut -f \
                --kver '${KERNEL_VERSION}' \
                --kernel-image '/workspace/build/arch/${MAKE_ARCH}/boot/Image' \
                --omit plymouth \
                --no-early-microcode \
                --kmoddir '/workspace/build/modules_staging/lib/modules/${KERNEL_VERSION}' \
                '/workspace/build/initramfs-${KERNEL_PREFIX}-${KERNEL_VERSION}.img' \
                ${ALL_ARGS_STRING} \
                --include /workspace/build/initramfs_extra /
        " >> "${LOG_FILE}" 2>&1
    then
        echo "${RED}${BOLD}Error: dracut inside container failed${NORMAL}"
        finish 1
    fi

    sudo chown "$(id -u):$(id -g)" "${INITRAMFS_PATH}" || true

    if [[ ! -f "${INITRAMFS_PATH}" ]]; then
        echo "${RED}${BOLD}Error:${NORMAL} initramfs not created"
        finish 1
    fi

    echo "${GREEN}${BOLD}Success${NORMAL}"
}

build_dtbs()
{
    echo ""
    echo "${WHITE}Building DTBs...${NORMAL}"
    echo "" >> "${LOG_FILE}"
    echo "" >> "${LOG_FILE}"
    echo "Building DTBs..." >> "${LOG_FILE}"
    echo "" >> "${LOG_FILE}"

    # Build DTBs.
    make -j"$(nproc)" \
        O="${KERNEL_BUILD_DIR}" \
        ARCH="${MAKE_ARCH}" \
        dtbs >> "${LOG_FILE}" 2>&1
    if [[ $? -ne 0 ]]; then
        echo "${RED}${BOLD}Error: DTB build failed.${NORMAL}"
        echo "Error: DTB build failed" >> "${LOG_FILE}"
        finish 1
    fi

    # Prepare destination path.
    local dtb_install_path="${KERNEL_BUILD_DIR}/deploy/dtbs"
    mkdir -p "${dtb_install_path}"

    # Install DTBs.
    make \
        O="${KERNEL_BUILD_DIR}" \
        ARCH="${MAKE_ARCH}" \
        INSTALL_DTBS_PATH="${dtb_install_path}" \
        dtbs_install >> "${LOG_FILE}" 2>&1
    if [[ $? -ne 0 ]]; then
        echo "${RED}${BOLD}Error: DTB install failed.${NORMAL}"
        echo "Error: DTB install failed" >> "${LOG_FILE}"
        finish 1
    fi

    echo "${GREEN}${BOLD}Success${NORMAL}"
}

copy_build_artifacts()
{
    local DEPLOY_DIR="${KERNEL_BUILD_DIR}/deploy"
    local DTBS_DIR="${DEPLOY_DIR}/dtbs"

    # Preserve DTBs if they exist
    if [[ -d "${DTBS_DIR}" ]]; then
        local TMP_DTBS
        TMP_DTBS=$(mktemp -d)
        cp -a "${DTBS_DIR}" "${TMP_DTBS}/"
    fi

    # Recreate deploy directory
    rm -rf "${DEPLOY_DIR}"
    mkdir -p "${DEPLOY_DIR}"

    # Restore DTBs if we saved them
    if [[ -d "${TMP_DTBS}/dtbs" ]]; then
        mv "${TMP_DTBS}/dtbs" "${DEPLOY_DIR}/"
        rmdir "${TMP_DTBS}"
    else
        # Create an empty dtbs/ directory so caller can expect it
        mkdir -p "${DTBS_DIR}"
    fi

    local KERNEL_IMAGE_SRC="${KERNEL_BUILD_DIR}/arch/arm64/boot/Image"
    local KERNEL_IMAGE_DST="${DEPLOY_DIR}/Image-${KERNEL_PREFIX}-${KERNEL_VERSION}"

    # Copy kernel Image
    if [[ -f "${KERNEL_IMAGE_SRC}" ]]; then
        cp "${KERNEL_IMAGE_SRC}" "${KERNEL_IMAGE_DST}"
    else
        echo "${RED}${BOLD}Error:${NORMAL} kernel Image not found at ${KERNEL_IMAGE_SRC}"
        finish 1
    fi

    # Copy initramfs
    if [[ "${BUILD_INITRAMFS:-false}" == "true" ]]; then
        if [[ -f "${INITRAMFS_PATH}" ]]; then
            cp "${INITRAMFS_PATH}" "${DEPLOY_DIR}/"
        else
            echo "${RED}${BOLD}Error:${NORMAL} initramfs was requested, but file not found:"
            echo "  ${CYAN}${INITRAMFS_PATH}"
            echo "${NORMAL}"
            finish 1
        fi
    fi

    # Output a summary
    echo ""
    echo "${WHITE}Build artifacts copied to:${CYAN}"
    echo "  ${KERNEL_IMAGE_DST}"
    if [[ "${BUILD_INITRAMFS:-false}" == "true" ]]; then
        echo "  ${INITRAMFS_PATH}"
    fi
    echo "  ${DTBS_DIR}/ (DTBs preserved)"
    echo "${NORMAL}"

    {
        echo ""
        echo "Build artifacts copied to:"
        echo "  ${KERNEL_IMAGE_DST}"
        if [[ "${BUILD_INITRAMFS:-false}" == "true" ]]; then
            echo "  ${INITRAMFS_PATH}"
        fi
        echo "  ${DTBS_DIR}/"
        echo ""
    } >> "${LOG_FILE}"
}

main ()
{
    # Ensure required environment variables are set.
    if [[ -z "${KERNEL_SRC_DIR}" || -z "${KERNEL_BUILD_DIR}" ]]; then
        echo "${RED}${BOLD}Error: KERNEL_SRC_DIR and KERNEL_BUILD_DIR not set."
        echo "${NORMAL}"
        finish 1
    else
        echo ""
        echo "${WHITE}KERNEL_SRC_DIR:   ${CYAN}${KERNEL_SRC_DIR}${NORMAL}"
        echo "${WHITE}KERNEL_BUILD_DIR: ${CYAN}${KERNEL_BUILD_DIR}"
        echo "${NORMAL}"
    fi

    parse_args "$@"
    check_args

    check_commands

    set_target_architecture

    create_log_file

    # Clone the CentOS Stream kernel source repository.
    if [[ "${GIT_CLONE}" == true ]]; then
        clone_kernel_repos
    fi

    # Prepare for backporting.
    if [[ "${BACKPORTING}" == "true" && ( "${UPSTREAM_REPO_NAME}" == "stable" || "${UPSTREAM_REPO_NAME}" == "next" ) ]]; then
        prepare_for_backporting
    fi

    # Change directory to the kernel source directory.
    if [[ -d "${KERNEL_SRC_DIR}" ]]; then
        cd "${KERNEL_SRC_DIR}" || exit 1
    else
        echo "${RED}${BOLD}Error: KERNEL_SRC_DIR does not exist: ${BRIGHT_BLUE}${BOLD}${KERNEL_SRC_DIR}"
        echo "${NORMAL}"
        finish 1
    fi

    # Clean, configure and generate ctags.
    if [[ "${CONFIGURE}" == "true" ]]; then
        clean_and_configure
        generate_ctags
    fi

    # Apply patches
    if [[ -n "${PATCHES_DIR}" && -d "${PATCHES_DIR}" ]]; then
        apply_kernel_patches
    fi

    # Build the kernel
    if [[ "${CONFIGURE}" != true ]]; then
        if [[ ! -f "${KERNEL_BUILD_DIR}/.config" ]]; then
            echo "${RED}${BOLD}Error: No existing .config found in ${KERNEL_BUILD_DIR}. Run with -c to configure first.${NORMAL}"
            finish 1
        fi
    fi

    # If this is an Orin Nano, set for performance mode.
    if grep -q "Orin Nano" /sys/firmware/devicetree/base/model; then
        echo "${WHITE}Setting for performance mode on Orin Nano..."
        echo "${NORMAL}"
        sudo cpupower frequency-set -g performance > /dev/null 2>&1
    fi

    rm -f "${KERNEL_BUILD_DIR}"/arch/arm64/boot/Image
    rm -f "${KERNEL_BUILD_DIR}"/arch/riscv/boot/Image
    rm -f "${KERNEL_BUILD_DIR}"/vmlinux

    START_TIME=$(date +%s)

    # Build the kernel.
    BUILD_RESULT=1
    if ! build_kernel; then
        echo "${RED}${BOLD}Kernel build failure${NORMAL}"
        finish 1
    else
        BUILD_RESULT=0
        echo "Kernel build success" >> "${LOG_FILE}"
        echo "" >> "${LOG_FILE}"
        echo "${GREEN}${BOLD}Success"
        echo "${NORMAL}"
    
        echo "${WHITE}Installing kernel modules...${NORMAL}"
        echo "Installing kernel modules..." >> "${LOG_FILE}"
        echo "" >> "${LOG_FILE}"
    
        # Create modules staging directory.
        KERNEL_MODROOT="${KERNEL_BUILD_DIR}/modules_staging"
        rm -rf "${KERNEL_MODROOT}"
        mkdir -p "${KERNEL_MODROOT}"
    
        # Install modules into staging area.
        make \
            -j"$(nproc)" \
            O="${KERNEL_BUILD_DIR}" \
            ARCH="${MAKE_ARCH}" \
            INSTALL_MOD_PATH="${KERNEL_MODROOT}" \
            modules_install >> "${LOG_FILE}" 2>&1
    
        if [[ $? -ne 0 ]]; then
            echo "${RED}${BOLD}Error: modules_install failed.${NORMAL}"
            finish 1
        fi
    
        # Fix permissions on modules directory
        sudo chown -R "$(id -u):$(id -g)" "${KERNEL_MODROOT}" || true
    fi

    END_TIME=$(date +%s)
    BUILD_DURATION=$((END_TIME - START_TIME))
    BUILD_MINUTES=$((BUILD_DURATION / 60))
    BUILD_SECONDS=$((BUILD_DURATION % 60))

    # Build the initramfs.
    if [[ "${BUILD_RESULT}" -eq 0 && "${BUILD_INITRAMFS:-false}" == "true" ]]; then
        build_initramfs
    fi

    # Build DTBs.
    if [[ "${BUILD_RESULT}" -eq 0 ]]; then
        build_dtbs
    fi

    # Copy Build artifcats.
    if [[ "${BUILD_RESULT}" -eq 0 ]]; then
        copy_build_artifacts
    fi

    # Show build results.
    echo "${WHITE}Build time: ${CYAN}${BUILD_MINUTES} min, ${BUILD_SECONDS} sec${NORMAL}"
    echo "Build time: ${BUILD_MINUTES} min, ${BUILD_SECONDS} sec" >> "${LOG_FILE}"
    echo ""

    echo "${GREEN}${BOLD}Done!"
    echo "${NORMAL}"

    finish "$BUILD_RESULT"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
    exit $?
fi
